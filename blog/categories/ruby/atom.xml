<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Winter'Blog]]></title>
  <link href="http://www.rails.pub/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.rails.pub/"/>
  <updated>2015-09-02T08:31:57+08:00</updated>
  <id>http://www.rails.pub/</id>
  <author>
    <name><![CDATA[Winter]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Function, Lambda, Proc, Blcok的区别]]></title>
    <link href="http://www.rails.pub/blog/2015/07/31/ruby/"/>
    <updated>2015-07-31T22:59:17+08:00</updated>
    <id>http://www.rails.pub/blog/2015/07/31/ruby</id>
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>方法名         </th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>function</td>
<td> 参数（可选，调用时需要匹配），有方法名，运行结果为对象，return跳出当前方法，任何地方都可以执行</td>
</tr>
<tr>
<td>lambda</td>
<td>参数（可选，调用时需要匹配），有块名，运行结果为对象，return跳出当前块，只有在函数体中或调用#call来执行</td>
</tr>
<tr>
<td>proc</td>
<td>参数（可选，调用时不必匹配），有块名，一个执行的过程，return跳出当前作用域，只有在函数体中或调用#call来执行</td>
</tr>
<tr>
<td>block</td>
<td>参数（可选，调用时不必匹配），匿名块，一个执行的过程，return跳出当前作用域，只能在函数体中执行</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Include和extend的使用]]></title>
    <link href="http://www.rails.pub/blog/2015/06/17/syntax/"/>
    <updated>2015-06-17T12:08:58+08:00</updated>
    <id>http://www.rails.pub/blog/2015/06/17/syntax</id>
    <content type="html"><![CDATA[<p>1.在类定义中引入模块，是模块中的方法成为类的实例方法。这种情况是最常见的，直接 <code>include</code> 即可。</p>

<pre><code class="ruby">module Basic
    def add(number)
        self + number
    end
end

Fixnum.class_eval do
    include Basic
end

3.add 4  #=&gt; 7 
</code></pre>

<p>2.在类定义中引入模块，使模块中的方法成为类的实例方法。这种情况也是比较常见的，直接 <code>extend</code> 即可。</p>

<pre><code class="ruby">module ExtendMe
    def verbal_object_id
         "my object id is #{self.object_id}"
    end
end

class Person
    extend ExtendMe
end

Person.verbal_object_id #=&gt; "my object id is 24339630"
</code></pre>

<p>3.有时在类定义中引入模块，既希望引入实例方法，也希望引入类方法，这时需要使用 <code>include</code> ，但是在模块中对类方法的定义有所不同，定义出现在</p>

<pre><code class="ruby">module ExtendThroughInclude
    def self.included(klass)
        klass.extend ClassMethods
    end

    def instance_method
        "this is an instance method of #{self.class}"
    end

    module ClassMethods
        def class_method
            "this is a method on the #{self} class"
        end
    end
end

class Person
    include ExtendThroughInclude
end

Person.new.instance_method #=&gt; "this is an instance method Person"
Person.new.instance_method #=&gt; "this is a method on the Person class"
</code></pre>
]]></content>
  </entry>
  
</feed>
